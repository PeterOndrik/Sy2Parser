#ifndef SY2PARSER_API_H
#define SY2PARSER_API_H

/*!
\file sy2parser_api.h
*/

/*!
\mainpage Sy2 Parser API

\tableofcontents

\section sec_introduction Introduction

A parser is a software component that takes input data and builds an abstract syntax tree (AST). The Sy2 Parser reads a symbol file in the Sy2 format and builds a corresponding AST.
This API provides functions to parse a file and read such created AST. The nodes in the tree have a hierarchical relationship to each other. The terms parent, child, and sibling are used to describe the relationships.


The Sy2 format is primarily designed for a test engine but contains lots of information for any tool which needs to work with symbols of a source program. A symbol represents 
a data type, variable or function. Each line starts with a command keyword followed by a value or the symbol attributes.

For example:
- command to specify a type of signature version of a symbol file (the signature describes a data type of a symbol):
\code
  TEngSetSignVersion 2016
\endcode

- commands to specify a variable of 32-bit integer data type and const pointer to unsigned char data type
C-style syntax: 
\code
  uint32_t var1;
  uint8_t * const var2;
\endcode
\code
# Command Type   Name            Address     Signature
# ------------------------------------------------------
RegCmd    DATA   var1            0040DD0C    I32
RegCmd    DATA   var2            0040DE20    C-PTR32-UI8
\endcode

A line started by the '#' sign is a comment. Columns "Type", "Name", "Address" and "Signature" are symbol attributes, where "Signature" describes data type. The Sy2 format is used to describe data type 
signature version 2016.

The Sy2 Parser generates following AST for example above:
\image html Sy2-1.PNG "Figure 1: Sy2 AST Example"

The signature is internally parsed separated Sign2016 Parser but the API provides the same functions.
For example AST for the signatures above is following:
<table align="center">
<tr>
<td>
\image html Sign2016-1.PNG Figure 2: Sign2016 "I32" AST Example
</td>
<td>
\image html Sign2016-2.PNG Figure 3: Sign2016 "C-PTR32-UI8" AST Example
</td>
</tr>
</table>
The Sy2 Parser is provided as dynamic link library. The following files are needed:
- bin\Release\Win32\sy2parser.dll
- bin\Release\Win32\sy2parser.lib
- Sy2Parser.C\\sy2parser_api.h - the C-style function signatures

The Sy2 Parser was generated by [ANTLR parser generator](https://github.com/antlr/antlr4).

\section sec_open_parse_view_example Read AST after parsing
To parse and display AST the following code can be used:
\code
#include "sy2parser_api.h"
#include <stdio.h>  // printf()
#include <string.h>  // memset()

#define INDENT_SIZE 100U

void setIndent(char *indent, int count)
{
  for (int i = 0; i < count; i++)
  {
    indent[i] = ' ';
  }
}

void resetIndent(char *indent)
{
  memset(indent, 0, INDENT_SIZE);
}

void SY2PARSER_API_CALL errorCallback(Sy2ParserHandle handle, unsigned int line, unsigned int column, const char *message, void *callbackContext)
{
  printf("Error: line %u, column %u, message %s\n", line, column, message);
}

void SY2PARSER_API_CALL progressCallback(Sy2ParserHandle handle, unsigned int progress, void *callbackContext)
{
  printf("Progress: %u%%\n", progress);
}

int main()
{
  Sy2ParserHandle handle = SY2PARSER_INVALID_HANDLE;
  T_Sy2Node node = { 0 };
  char indent[INDENT_SIZE] = { 0 };

  // initialization
  Sy2ParserStatus status = sy2Open("test.sy2", &handle);
  status = sy2SetParsingErrorCallback(handle, errorCallback, NULL);
  status = sy2SetParsingProgressCallback(handle, progressCallback, NULL);

  // parsing
  status = sy2Parse(handle);

  // printing AST
  status = sy2ReadNext(handle, &node);
  while (status != SY2_EOF)
  {
    setIndent(indent, node.depth);
    printf("%s%s: %s\n", indent, sy2NodeName[node.type], node.value);
    resetIndent(indent);

    status = sy2ReadNext(handle, &node);
  }

  // closing
  status = sy2Close(handle);

  return 0;
}
\endcode

Input the test.sy2 file:
\code
# Header

Encoding little_endian

TEngSetSignVersion 2016

# Command Type   Name            Address     Signature
# ------------------------------------------------------
RegCmd    DATA   var1            0040DD0C    I32
RegCmd    DATA   var2            0040DE20    C-PTR32-UI8
\endcode

Output:
\code
Progress: 9%
Progress: 75%
Progress: 99%
Progress: 100%

FILE: test.sy2
 COMMAND: Encoding
  CMD_VALUE: little_endian
 COMMAND: TEngSetSignVersion
  CMD_VALUE: 2016
 COMMAND: RegCmd
  SYMBOL: var1
   TYPE: DATA
   NAME: var1
   ADDRESS: 0040DD0C
   SIGNATURE: I32
    INT: I
     SIZE: 32
 COMMAND: RegCmd
  SYMBOL: var2
   TYPE: DATA
   NAME: var2
   ADDRESS: 0040DE20
   SIGNATURE: C_PTR32_UI8
    POINTER: PTR
     TYPE_QUALIFIER: C
     SIZE: 32
     UINT: UI
      SIZE: 8
\endcode

\section sec_open_parse_callback_example Read AST during parsing
\code
#include "sy2parser_api.h"
#include <stdio.h>  // printf()
#include <string.h>  // memset()

#define INDENT_SIZE 100U

void setIndent(char *indent, int count)
{
  for (int i = 0; i < count; i++)
  {
    indent[i] = ' ';
  }
}

void resetIndent(char *indent)
{
  memset(indent, 0, INDENT_SIZE);
}

void SY2PARSER_API_CALL errorCallback(Sy2ParserHandle handle, unsigned int line, unsigned int column, const char *message, void *callbackContext)
{
  printf("Error: line %u, column %u, message %s\n", line, column, message);
}

void SY2PARSER_API_CALL progressCallback(Sy2ParserHandle handle, unsigned int progress, void *callbackContext)
{
  printf("Progress: %d%%\n", progress);
}

void SY2PARSER_API_CALL parsedNodeCallback(Sy2ParserHandle handle, const T_Sy2Node *node, void *callbackContext)
{
  char indent[INDENT_SIZE] = { 0 };

  setIndent(indent, node->depth);
  printf("%s%s (0x%04X): %s\n", indent, sy2NodeName[node->type], node->status, node->value);

  T_Sy2Node newNode = { 0 };
  Sy2ParserStatus status = sy2ReadNext(handle, &newNode);
  while (newNode.depth > node->depth)
  {
    setIndent(indent, newNode.depth);
    printf("%s%s (0x%04X): %s\n", indent, sy2NodeName[newNode.type], status, newNode.value);
    resetIndent(indent);

    status = sy2ReadNext(handle, &newNode);
  }
  printf("\n");
}

int main()
{
  Sy2ParserHandle handle = SY2PARSER_INVALID_HANDLE;

  // initialization
  Sy2ParserStatus status = sy2Open("test.sy2", &handle);
  status = sy2SetParsingErrorCallback(handle, errorCallback, NULL);
  status = sy2SetParsingProgressCallback(handle, progressCallback, NULL);
  status = sy2AddParsedNodeCallback(handle, SY2_COMMAND, parsedNodeCallback, NULL);

  // parsing
  status = sy2Parse(handle);

  // closing
  status = sy2Close(handle);

  return 0;
}
\endcode

Input the test.sy2 file:
\code
# Header

Encoding little_endian

TEngSetSignVersion 2016

# Structure TAG PointTag, sizeof(PointTag) is 16 Byte(s):
# Command Type   Name            Offset      Signature
# ----------------------------------------------------------------------------
RegVar    STRUCT PointTag        0           S128-PointTag
RegVar    STRUCT PointTag_x      0           F32
RegVar    STRUCT PointTag_y      4           F96

# Command Type   Name            Address     Signature
# ----------------------------------------------------------------------------
RegCmd    DATA   var1            0040DC20    UI32
RegCmd    DATA   var2            0040DD0C    C-UI8
RegCmd    DATA   var3            0040DE20    C-PTR32-C-I32
RegCmd    DATA   point1          0040DF20    S128-PointTag
RegCmd    DATA   point1_x        0040DF20    F32
RegCmd    DATA   point1_y        0040DF24    F96

# Command Type   Name            Address     Signature
# -----------------------------------------------------------------------------
RegCmd    PROC   func1           080020C5    FB-V-PTR32-C-S128-PointTag-UI32-FE
\endcode

Output:
\code
Progress: 2%
 COMMAND (0x0000): Encoding
  CMD_VALUE (0x0000): little_endian

Progress: 4%
 COMMAND (0x0000): TEngSetSignVersion
  CMD_VALUE (0x0000): 2016

Progress: 27%
 COMMAND (0x0000): RegVar
  TYPEDEF (0x0000): PointTag
   TYPE (0x0000): STRUCT
   NAME (0x0000): PointTag
   OFFSET (0x0000): 0
   SIGNATURE (0x0000): S128-PointTag
	STRUCT (0x0000): PointTag
	 SIZE (0x0000): 128

Progress: 35%
 COMMAND (0x0000): RegVar
  TYPEDEF (0x0000): PointTag_x
   TYPE (0x0000): STRUCT
   NAME (0x0000): PointTag_x
   OFFSET (0x0000): 0
   SIGNATURE (0x0000): F32
	FLOAT (0x0000): F
	 SIZE (0x0000): 32

Progress: 39%
 COMMAND (0x0000): RegVar
  TYPEDEF (0x0000): PointTag_y
   TYPE (0x0000): STRUCT
   NAME (0x0000): PointTag_y
   OFFSET (0x0000): 4
   SIGNATURE (0x0000): F96
	FLOAT (0x0000): F
	 SIZE (0x0000): 96

Progress: 54%
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var1
   TYPE (0x0000): DATA
   NAME (0x0000): var1
   ADDRESS (0x0000): 0040DC20
   SIGNATURE (0x0000): UI32
	UINT (0x0000): UI
	 SIZE (0x0000): 32

Progress: 58%
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var2
   TYPE (0x0000): DATA
   NAME (0x0000): var2
   ADDRESS (0x0000): 0040DD0C
   SIGNATURE (0x0000): C-UI8
	UINT (0x0000): UI
	 TYPE_QUALIFIER (0x0000): C
	 SIZE (0x0000): 8

Progress: 62%
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var3
   TYPE (0x0000): DATA
   NAME (0x0000): var3
   ADDRESS (0x0000): 0040DE20
   SIGNATURE (0x0000): C-PTR32-C-I32
	POINTER (0x0000): PTR
	 TYPE_QUALIFIER (0x0000): C
	 SIZE (0x0000): 32
	 INT (0x0000): I
	  TYPE_QUALIFIER (0x0000): C
	  SIZE (0x0000): 32

Progress: 71%
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): point1
   TYPE (0x0000): DATA
   NAME (0x0000): point1
   ADDRESS (0x0000): 0040DF20
   SIGNATURE (0x0000): S128-PointTag
	STRUCT (0x0000): PointTag
	 SIZE (0x0000): 128

Progress: 79%
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): point1_x
   TYPE (0x0000): DATA
   NAME (0x0000): point1_x
   ADDRESS (0x0000): 0040DF20
   SIGNATURE (0x0000): F32
	FLOAT (0x0000): F
	 SIZE (0x0000): 32

Progress: 83%
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): point1_y
   TYPE (0x0000): DATA
   NAME (0x0000): point1_y
   ADDRESS (0x0000): 0040DF24
   SIGNATURE (0x0000): F96
	FLOAT (0x0000): F
	 SIZE (0x0000): 96

Progress: 99%
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): func1
   TYPE (0x0000): PROC
   NAME (0x0000): func1
   ADDRESS (0x0000): 080020C5
   SIGNATURE (0x0000): FB-V-PTR32-C-S128-PointTag-UI32-FE
	FUNCTION (0x0000): FB-V-PTR32-C-S128-PointTag-UI32-FE
	 RETURN (0x0000): V
	  VOID (0x0000): V
	 PARAMETER (0x0000): PTR32-C-S128-PointTag
	  POINTER (0x0000): PTR
	   SIZE (0x0000): 32
	   STRUCT (0x0000): PointTag
		TYPE_QUALIFIER (0x0000): C
		SIZE (0x0000): 128
	 PARAMETER (0x0000): UI32
	  UINT (0x0000): UI
	   SIZE (0x0000): 32

Progress: 100%
\endcode

\section sec_error_handling Error Handling
There are four parsing errors which a user can handle:

- SY2_INPUT_MISMATCHED 0x1000 - This signifies any kind of mismatched input error such as when the current input does not match the expected token.
- SY2_EXTRAENOUS_INPUT 0x1001 - Requires the removal of a token from the input stream.
- SY2_NO_VIABLE_ALTERNATIVE 0x1002 - Indicates that the parser could not decide which of two or more paths to take based upon the remaining input.
- SY2_MISSING_TOKEN 0x1003 - Requires the insertion of a missing token into the input stream.

If some node is not recognized will be tagged as UNSPECIFIED.

The examples below display nodes following way:

	<node-type> (<error-code>): <node-value>

	UNSPECIFIED (0x0000): errRegCmd - the UNSPECIFIED node has always error code 0x0000
	ADDRESS (0x1000): err00400000 - the ADDRESS node with error code 0x1000

The following source code is used:
\code
void SY2PARSER_API_CALL errorCallback(Sy2ParserHandle handle, unsigned int line, unsigned int column, unsigned int code, const char *message, void *callbackContext)
{
  printf("Error: line %u, column %u, code 0x%04X, message %s\n", line, column, code, message);
}

int main()
{
  Sy2ParserHandle handle = SY2PARSER_INVALID_HANDLE;
  T_Sy2Node node = { 0 };

  Sy2ParserStatus status = sy2Open("test.sy2", &handle);
  status = sy2SetParsingErrorCallback(handle, errorCallback, NULL);

  status = sy2Parse(handle);

  status = sy2ReadNext(handle, &node);
  while (status != SY2_EOF)
  {
    printf("%s (0x%04X): %s\n", sy2NodeName[node.type], status, node.value);

    status = sy2ReadNext(handle, &node);
  }

  status = sy2Close(handle);

  return 0;
}
\endcode

\subsection sec_example_1 Example 1: Error Code SY2_INPUT_MISMATCHED
\code
errRegCmd DATA var1 00400000 I32
RegCmd DATA var2 00400004 I32
RegCmd DATA var3 00400008 I32
\endcode
Output:
\code
Error: line 1, column 1, code 0x1000, message mismatched input 'errRegCmd' expecting {'Encoding', 'TEngSetSignVersion', 'RegVar', 'RegCmd', NL}

FILE (0x1000): ..\Test\In\test.sy2
 UNSPECIFIED (0x0000): errRegCmd
 UNSPECIFIED (0x0000): DATA
 UNSPECIFIED (0x0000): var1
 UNSPECIFIED (0x0000): 00400000
 UNSPECIFIED (0x0000): I32
 UNSPECIFIED (0x0000):

 UNSPECIFIED (0x0000): RegCmd
 UNSPECIFIED (0x0000): DATA
 UNSPECIFIED (0x0000): var2
 UNSPECIFIED (0x0000): 00400004
 UNSPECIFIED (0x0000): I32
 UNSPECIFIED (0x0000):

 UNSPECIFIED (0x0000): RegCmd
 UNSPECIFIED (0x0000): DATA
 UNSPECIFIED (0x0000): var3
 UNSPECIFIED (0x0000): 00400008
 UNSPECIFIED (0x0000): I32
 UNSPECIFIED (0x0000):
 \endcode

\subsection sec_example_2 Example 2: Error Code SY2_EXTRAENOUS_INPUT
\code
RegCmd DATA var1 00400000 I32
errRegCmd DATA var2 00400004 I32
RegCmd DATA var3 00400008 I32
\endcode
Output:
\code
Error: line 2, column 1, code 0x1001, message extraneous input 'errRegCmd' expecting {<EOF>, 'Encoding', 'TEngSetSignVersion', 'RegVar', 'RegCmd', NL}

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var1
   TYPE (0x0000): DATA
   NAME (0x0000): var1
   ADDRESS (0x0000): 00400000
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
 UNSPECIFIED (0x0000): errRegCmd
 UNSPECIFIED (0x0000): DATA
 UNSPECIFIED (0x0000): var2
 UNSPECIFIED (0x0000): 00400004
 UNSPECIFIED (0x0000): I32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var3
   TYPE (0x0000): DATA
   NAME (0x0000): var3
   ADDRESS (0x0000): 00400008
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
\endcode

\subsection sec_example_3 Example 3: Error code SY2_INPUT_MISMATCHED in a type of SYMBOL or TYPEDEF
\code
RegCmd errDATA var1 00400000 I32
RegCmd DATA var2 00400004 I32
RegCmd DATA var3 00400008 I32
\endcode
Output:
\code
Error: line 1, column 8, code 0x1000, message mismatched input 'errDATA' expecting {PROC, DATA}

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegCmd
  SYMBOL (0x1000): <missing TYPE>
   UNSPECIFIED (0x0000): errDATA
   UNSPECIFIED (0x0000): var1
   UNSPECIFIED (0x0000): 00400000
   UNSPECIFIED (0x0000): I32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var2
   TYPE (0x0000): DATA
   NAME (0x0000): var2
   ADDRESS (0x0000): 00400004
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var3
   TYPE (0x0000): DATA
   NAME (0x0000): var3
   ADDRESS (0x0000): 00400008
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
\endcode

\subsection sec_example_4 Example 4: Error code SY2_INPUT_MISMATCHED in an ADDRESS
\code
RegCmd DATA var1 err00400000 I32
RegCmd DATA var2 00400004 I32
RegCmd DATA var3 00400008 I32
\endcode
Output:
\code
Error: line 1, column 18, code 0x1000, message mismatched input 'err00400000' expecting ADDRESS

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var1
   TYPE (0x0000): DATA
   NAME (0x0000): var1
   ADDRESS (0x1000): err00400000
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var2
   TYPE (0x0000): DATA
   NAME (0x0000): var2
   ADDRESS (0x0000): 00400004
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var3
   TYPE (0x0000): DATA
   NAME (0x0000): var3
   ADDRESS (0x0000): 00400008
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
\endcode

\subsection sec_example_5 Example 5: Error code SY2_INPUT_MISMATCHED in a SIGNATURE
\code
RegCmd DATA var1 00400000 errI32
RegCmd DATA var2 00400004 I32
RegCmd DATA var3 00400008 I32
\endcode
Output:
\code
Error: line 1, column 33, code 0x1000, message mismatched input '<EOF>' expecting {'C', 'B', 'I', 'UI', 'F', 'S', 'PTR', 'FB'}

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var1
   TYPE (0x0000): DATA
   NAME (0x0000): var1
   ADDRESS (0x0000): 00400000
   SIGNATURE (0x1000): errI32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var2
   TYPE (0x0000): DATA
   NAME (0x0000): var2
   ADDRESS (0x0000): 00400004
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var3
   TYPE (0x0000): DATA
   NAME (0x0000): var3
   ADDRESS (0x0000): 00400008
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
\endcode

\subsection sec_example_6 Example 6: Error Code SY2_MISSING_TOKEN - missing a SIGNATURE
\code
RegCmd DATA var1 00400000
RegCmd DATA var2 00400004 I32
RegCmd DATA var3 00400008 I32
\endcode
Output:
\code
Error: line 1, column 26, code 0x1003, message missing SIGNATURE at '\n'

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var1
   TYPE (0x0000): DATA
   NAME (0x0000): var1
   ADDRESS (0x0000): 00400000
   SIGNATURE (0x1003): <missing SIGNATURE>
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var2
   TYPE (0x0000): DATA
   NAME (0x0000): var2
   ADDRESS (0x0000): 00400004
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): var3
   TYPE (0x0000): DATA
   NAME (0x0000): var3
   ADDRESS (0x0000): 00400008
   SIGNATURE (0x0000): I32
	INT (0x0000): I
	 SIZE (0x0000): 32
\endcode

\subsection sec_example_7 Example 7: Error Code SY2_NO_VIABLE_ALTERNATIVE - missing a structure name in a SIGNATURE
\code
RegCmd DATA point1 0040DD24 S128-
\endcode
Output:
\code
Error: line 1, column 34, code 0x1002, message no viable alternative at input '-'

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): point1
   TYPE (0x0000): DATA
   NAME (0x0000): point1
   ADDRESS (0x0000): 0040DD24
   SIGNATURE (0x0000): S128-
	STRUCT (0x1002): <missing NAME>
	 SIZE (0x0000): 128
\endcode

\subsection sec_example_8 Example 8: Error Code SY2_MISSING_TOKEN - missing a BITMASK
\code
RegVar BIT BitFieldTag 0 S64-BitFieldTag
RegVar BIT BitFieldTag_a 0 UI32
RegVar BIT BitFieldTag_b 0 0x12 UI32
RegVar BIT BitFieldTag_c 1 UI32
\endcode
Output:
\code
Error: line 1, column 26, code 0x1003, message missing BITMASK at 'S64-BitFieldTag'
Error: line 2, column 28, code 0x1003, message missing BITMASK at 'UI32'
Error: line 4, column 28, code 0x1003, message missing BITMASK at 'UI32'

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegVar
  TYPEDEF (0x0000): BitFieldTag
   TYPE (0x0000): BIT
   NAME (0x0000): BitFieldTag
   OFFSET (0x0000): 0
   BITMASK (0x1003): <missing BITMASK>
   SIGNATURE (0x0000): S64-BitFieldTag
	STRUCT (0x0000): BitFieldTag
	 SIZE (0x0000): 64
 COMMAND (0x0000): RegVar
  TYPEDEF (0x0000): BitFieldTag_a
   TYPE (0x0000): BIT
   NAME (0x0000): BitFieldTag_a
   OFFSET (0x0000): 0
   BITMASK (0x1003): <missing BITMASK>
   SIGNATURE (0x0000): UI32
	UINT (0x0000): UI
	 SIZE (0x0000): 32
 COMMAND (0x0000): RegVar
  TYPEDEF (0x0000): BitFieldTag_b
   TYPE (0x0000): BIT
   NAME (0x0000): BitFieldTag_b
   OFFSET (0x0000): 0
   BITMASK (0x0000): 0x12
   SIGNATURE (0x0000): UI32
	UINT (0x0000): UI
	 SIZE (0x0000): 32
 COMMAND (0x0000): RegVar
  TYPEDEF (0x0000): BitFieldTag_c
   TYPE (0x0000): BIT
   NAME (0x0000): BitFieldTag_c
   OFFSET (0x0000): 1
   BITMASK (0x1003): <missing BITMASK>
   SIGNATURE (0x0000): UI32
	UINT (0x0000): UI
	 SIZE (0x0000): 32
\endcode

\subsection sec_example_9 Example 9: Error Code SY2_EXTRAENOUS_INPUT and SY2_NO_VIABLE_ALTERNATIVE inside node
\code
RegCmd PROC Func1 2004EAF8 FB-I32-PTR32-S64-Struct1
\endcode
There is missing the end of function, the '-FE' keyword. At first the parser generates error code SY2_EXTRAENOUS_INPUT
and tries to use the keyword which could potentially follow. It is '-'. But then the parser could not decide which of
two or more paths to take for the remaining input. The same as in example 7. The array size or structure name could follow.

Output:
\code
Error: line 1, column 52, code 0x1001, message extraneous input '<EOF>' expecting '-'

FILE (0x0000): ..\Test\In\test.sy2
 COMMAND (0x0000): RegCmd
  SYMBOL (0x0000): Func1
   TYPE (0x0000): PROC
   NAME (0x0000): Func1
   ADDRESS (0x0000): 2004EAF8
   SIGNATURE (0x0000): FB-I32-PTR32-S64-Struct1
	FUNCTION (0x1002): FB-I32-PTR32-S64-Struct1
	 RETURN (0x0000): I32
	  INT (0x0000): I
	   SIZE (0x0000): 32
	 PARAMETER (0x0000): PTR32-S64-Struct1
	  POINTER (0x0000): PTR
	   SIZE (0x0000): 32
	   STRUCT (0x0000): Struct1
		SIZE (0x0000): 64
\endcode
*/

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the SY2PARSER_API_EXPORT
// symbol defined on the command line. This symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// SY2PARSER_API functions as being imported from a DLL, whereas this DLL sees symbols
// defined with this macro as being exported.
#ifdef SY2PARSER_API_EXPORT
// API function declaration used if the .h file is included by the DLL implementation itself.
#define SY2PARSER_API __declspec(dllexport)
#else
// API function declaration used if the .h file is included (imported) by client code.
#define SY2PARSER_API __declspec(dllimport)
#endif

// Calling convention of exported API functions.
#define SY2PARSER_API_CALL __stdcall

#ifdef __cplusplus
extern "C" {
#endif

/*!
\defgroup sy2parser_api_version_constants Interface Version Constants
@{

\brief Version number of the programming interface exported from the DLL.

If changes are made to the interface that are compatible with previous versions
of the interface then the minor version number will be incremented.
If changes are made to the interface that cause an incompatibility with previous versions
of the interface then the major version number will be incremented.

It can use udaGetApiVersion() to retrieve the API version implemented by the DLL.
*/
//! Major version number of the programming interface.
#define SY2PARSER_API_MAJOR_VERSION   2U
//! Minor version number of the programming interface.
#define SY2PARSER_API_MINOR_VERSION   0U

//! Version number of the programming interface as DWORD.
#define SY2PARSER_API_VERSION ( (SY2PARSER_API_MAJOR_VERSION << 16) | SY2PARSER_API_MINOR_VERSION ) 
/*!
@}
*/

/*!
\defgroup uda_device_constants_types Constants and Types
@{

\brief Constants and types used in the programming interface.
*/

//! The value zero is an invalid handle.
#define SY2PARSER_INVALID_HANDLE	0U

//! The size of a node value.
#define SY2_VALUE_SIZE 512

//! Status code returned by API functions.
typedef unsigned int Sy2ParserStatus;

//! Sy2 Parser handle type used by the DLL. The value #SY2PARSER_INVALID_HANDLE (zero) is an invalid handle.
typedef unsigned int Sy2ParserHandle;

//! Sy2 Parser status codes
typedef enum Sy2ParserStatusCode
{
	SY2_SUCCESS					= 0x0000,			//!< The operation completed successfully.
	SY2_FAILD					= 0x0001,			//!< The operation failed.
	SY2_FILE_NOT_FOUND			= 0x0002,			//!< File not found.
	SY2_EOF						= 0x0003,			//!< End of file.
	SY2_INVALID_HANDLE			= 0x0004,			//!< An invalid parser handle.
	SY2_INPUT_MISMATCHED		= 0x1000,			//!< This signifies any kind of mismatched input error such as when the current input does not match the expected token.
	SY2_EXTRAENOUS_INPUT		= 0x1001,			//!< A syntax error which requires the removal of a token from the input stream.
	SY2_NO_VIABLE_ALTERNATIVE	= 0x1002,			//!< Indicates that the parser could not decide which of two or more paths to take based upon the remaining input.
	SY2_MISSING_TOKEN			= 0x1003,			//!< This method is called to report a syntax error which requires the insertion of a missing token into the input stream.
	SY2_PARSING_ABORTED			= 0x1FFE,			//!< Occurs when parsing was canceled by user.
	SY2_UNKNOWN					= 0x1FFF			//!< An unknown error.
} T_Sy2ParserStatusCode;

//! Sy2 Node types.
typedef enum Sy2NodeType
{
	SY2_UNSPECIFIED,
	SY2_FILE,
	SY2_COMMAND,
	SY2_CMD_VALUE,
	SY2_TYPEDEF,
	SY2_SYMBOL,
	SY2_TYPE,
	SY2_NAME,
	SY2_BITMASK,
	SY2_OFFSET,
	SY2_ADDRESS,
	SY2_ENUM_VALUE,
	SY2_SIGNATURE,
	SY2_VOID,
	SY2_BOOL,
	SY2_INT,
	SY2_UINT,
	SY2_FLOAT,
	SY2_STRUCT,
	SY2_POINTER,
	SY2_FUNCTION,
	SY2_RETURN,
	SY2_PARAMETER,
	SY2_TYPE_QUALIFIER,
	SY2_SIZE,
	SY2_ARRAY_SIZE,
	SY2_NODE_COUNT
} T_Sy2NodeType;

//! Sy2 Node type names.
const char *sy2NodeName[SY2_NODE_COUNT] = {
	"UNSPECIFIED",
	"FILE",
	"COMMAND",
	"CMD_VALUE",
	"TYPEDEF",
	"SYMBOL",
	"TYPE",
	"NAME",
	"BITMASK",
	"OFFSET",
	"ADDRESS",
	"ENUM_VALUE",
	"SIGNATURE",
	"VOID",
	"BOOL",
	"INT",
	"UINT",
	"FLOAT",
	"STRUCT",
	"POINTER",
	"FUNCTION",
	"RETURN",
	"PARAMETER",
	"TYPE_QUALIFIER",
	"SIZE",
	"ARRAY_SIZE"
};

//! The basic information to unique Sy2 node identification. The Sy2 node represents a terminal and a non-terminal lexical token.
typedef struct Sy2Node
{
	T_Sy2NodeType type;				//!< The type of a node see #Sy2NodeType.
	char value[SY2_VALUE_SIZE];		//!< The value of a node.
	unsigned int depth;				//!< The length of the path from root to the end.
	unsigned int line;				//!< The number of line.
	unsigned int column;			//!< The column of character.
	unsigned int status;			//!< The status code of a processed node.
} T_Sy2Node;

//! The date and time of a parsed file.
typedef struct FileDateTime
{
	unsigned short year;			//!< The year.
	unsigned short month;			//!< The month.
	unsigned short dayOfWeek;		//!< The day of the week. 0 - Sunday, ..., 6 - Saturday
	unsigned short day;				//!< The day of the month. The valid values for this member are 1 through 31.
	unsigned short hour;			//!< The hour. The valid values for this member are 0 through 23.
	unsigned short minute;			//!< The minute. The valid values for this member are 0 through 59.
	unsigned short second;			//!< The second. The valid values for this member are 0 through 59.
	unsigned short milliseconds;	//!< The millisecond.The valid values for this member are 0 through 999.
} T_FileDateTime;

//! The parsed file information.
typedef struct Sy2FileInfo
{
	unsigned int size;				//!< The size of the specified file, in bytes.
	T_FileDateTime creation;		//!< The date and time the file was created.
	T_FileDateTime lastAccess;		//!< The date and time the file was last accessed.
	T_FileDateTime lastWrite;		//!< The date and time the file was last written to.
} T_Sy2FileInfo;

/*!
@}
*/

/*!
\defgroup sy2parser_api_functions Sy2 Parser API Functions
@{

\brief Functions exported from the DLL and called by the application.
*/

/*!
  \brief Callback function which is called when an error occurs.

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \param[in] line
	The number of line.

  \param[in] column
	The number of column.

  \param[in] status
    The status.

  \param[in] message
	The error message.

  \param[in] callbackContext
	The pointer value that was passed when the callback was registered.
*/
typedef void SY2PARSER_API_CALL ParsingErrorCallback(Sy2ParserHandle handle, unsigned int line, unsigned int column, unsigned int status, const char *message, void *callbackContext);

/*!
  \brief Callback function which is called when parsing progress is changed.

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \param[in] progress
	The value of progress in percentages.
	
  \param[in] callbackContext
	The pointer value that was passed when the callback was registered.
*/
typedef void SY2PARSER_API_CALL ParsingProgressCallback(Sy2ParserHandle handle, unsigned int progress, void *callbackContext);

/*!
  \brief Callback function which is called after a node is completely parsed.

  Otherwise the ParsingErrorCallback is called.

  The entire subtree must be read by the sy2ReadNext() function. For example:
  \code
	void SY2PARSER_API_CALL parsedNodeCallback(Sy2ParserHandle handle, const T_Sy2Node *node, void *callbackContext)
	{
	  // the first node
	  printf("%u: %s\n", node->type, node->value);
	  T_Sy2Node newNode = { 0 };

	  // read first child node
	  Sy2ParserStatus status = sy2ReadNext(handle, &newNode);
	  while (status == SY2_SUCCESS && newNode.depth > node->depth)
	  {
		// display child node
		printf("%u: %s\n", newNode.type, newNode.value);
		// read next child node
		status = sy2ReadNext(handle, &newNode);
	  }
	}
  \endcode

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \param[in] node
	Information about parsed node.

  \param[in] callbackContext
	The pointer value that was passed when the callback was registered.
*/
typedef void SY2PARSER_API_CALL ParsedNodeCallback(Sy2ParserHandle handle, const T_Sy2Node *node, void *callbackContext);

/*!
  \brief Returns the API version implemented by the DLL.

  \return
	This function returns the version number of the programming interface (API) implemented by the DLL.
	The number returned is the #SY2PARSER_API_VERSION constant the DLL has been compiled with. For example 1.2 = 0x00010002.
*/
SY2PARSER_API unsigned int SY2PARSER_API_CALL sy2GetApiVersion(void);

/*!
  \brief Returns the DLL build version.

  Note that the version of the programming interface supported by the DLL is returned by udaGetApiVersion().

  \return
	This function returns the version number of the DLL build. For example 1.0.4.29 = 0x0100041D.
*/
SY2PARSER_API unsigned int SY2PARSER_API_CALL sy2GetDllVersion(void);

/*!
\brief Open a Sy2 Parser by using a file name.

\param[in] fileName
Specifies the name of a file to be parse.

\param[out] handle
Address of a caller-provided variable which will be set to a handle value if the function succeeds.
The handle represents a Sy2 Parser instance and is required for all subsequent API calls.
Note that the value #SY2PARSER_INVALID_HANDLE (zero) is an invalid handle.
If the function succeeds it will return a valid non-zero handle.

\return
The function returns #SY2_SUCCESS if successful, an error code otherwise.
Some specific error codes are described below.

\retval #SY2_FILE_NOT_FOUND
The file is not present.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2Open(const char *fileName, Sy2ParserHandle *handle);

/*!
\brief Close an opened Sy2 Parser.

The specified Sy2 Parser will be closed and the provided handle becomes invalid
after this call. The handle must not be used with any further API calls.

\param[in] handle
A descriptor identifying a Sy2 Parser.
The specified handle becomes invalid after this call and must not be used with any subsequent call.

\return
The function returns #SY2_SUCCESS if successful, an error code otherwise.
If a valid handle is specified, the function returns always #SY2_SUCCESS.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2Close(Sy2ParserHandle handle);

/*!
\brief Get information abut a parsed file.

\param[in] handle
A descriptor identifying a Sy2 Parser.

\param[out] fileInfo
Address of a caller-provided variable which will be set to a parsed file information if the function succeeds.

\return
The function returns #SY2_SUCCESS if successful, an error code otherwise.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2GetFileInfo(Sy2ParserHandle handle, T_Sy2FileInfo *fileInfo);

/*!
  \brief Set a callback to receive a parsing error.

  The callback is invoked during running the #sy2Parse() function.

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \param[in] callback
	Address of a caller-provided callback function.

  \param[in] callbackContext
	Caller-provided pointer which will be passed to the callback function unmodified. Can be set to NULL if unused.

  \return
	The function returns #SY2_SUCCESS if successful, an error code otherwise.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2SetParsingErrorCallback(Sy2ParserHandle handle, ParsingErrorCallback *callback, void *callbackContext);

/*!
  \brief Set a callback to receive a parsing progress.

  The callback is invoked during running the #sy2Parse() function.

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \param[in] callback
	Address of a caller-provided callback function.

  \param[in] callbackContext
	Caller-provided pointer which will be passed to the callback function unmodified. Can be set to NULL if unused.

  \return
	The function returns #SY2_SUCCESS if successful, an error code otherwise.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2SetParsingProgressCallback(Sy2ParserHandle handle, ParsingProgressCallback *callback, void *callbackContext);

/*!
  \brief Add a callback to receive a parsed node.

  The callback is invoked during running the #sy2Parse() function.

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \param[in] nodeType
    A node type for which the specified callback will be called only. See #Sy2NodeType.

  \param[in] callback
	Address of a caller-provided callback function.

  \param[in] callbackContext
	Caller-provided pointer which will be passed to the callback function unmodified. Can be set to NULL if unused.

  \return
	The function returns #SY2_SUCCESS if successful, an error code otherwise.
*/

SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2AddParsedNodeCallback(Sy2ParserHandle handle, T_Sy2NodeType nodeType, ParsedNodeCallback *callback, void *callbackContext);

/*!
  \brief Remove already added callback to receive a parsed node.

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \param[in] nodeType
	A node type for which the specified callback will be called only. See #Sy2NodeType.

  \param[in] callback
	Address of a caller-provided callback function.

  \return
	The function returns #SY2_SUCCESS if successful, an error code otherwise.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2RemoveParsedNodeCallback(Sy2ParserHandle handle, T_Sy2NodeType nodeType, ParsedNodeCallback *callback);

/*!
  \brief Perform a single-call parse of an Sy2 file associated with a handle. This function internally creates AST which can be read by using #sy2ReadNext() funcition after or during parsing.

  While sy2Parse() is running the previously registered callbacks are invoked. Functions sy2SetParsingErrorCallback(), sy2SetParsingProgressCallback() and sy2AddParsedNodeCallback().

  \param[in] handle
	A descriptor identifying an open Sy2 parser.

  \return
	The function returns #SY2_SUCCESS if successful, an error code otherwise.

  \retval #SY2_PARSING_ABORTED
    The parsing has been canceled. The AST may be incomplete.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2Parse(Sy2ParserHandle handle);

/*!
  \brief Read next node in generated AST.

  \param[in] handle
    A descriptor identifying an open Sy2 parser.

  \param[out] node
    Node information.

  \return
	The function returns #SY2_SUCCESS if successful, an error code otherwise.

  \retval #SY2_EOF
	End of file.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2ReadNext(Sy2ParserHandle handle, T_Sy2Node *node);

/*!
\brief Terminate the parsing process that is currently being performed. 

\param[in] handle
A descriptor identifying a Sy2 Parser.

\return
The function returns #SY2_SUCCESS if successful, an error code otherwise.
*/
SY2PARSER_API Sy2ParserStatus SY2PARSER_API_CALL sy2AbortParsing(Sy2ParserHandle handle);

/*!
@}
*/

/*!
\defgroup sy2parser_api_runtime Run-Time DL API
@{

\brief API function signatures for run-time dynamic linking.
*/

typedef unsigned int(SY2PARSER_API_CALL *T_sy2GetApiVersion)(void);
typedef unsigned int(SY2PARSER_API_CALL *T_sy2GetDllVersion)(void);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2Open)(const char *fileName, Sy2ParserHandle *handle);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2Close)(Sy2ParserHandle handle);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2GetFileInfo)(Sy2ParserHandle handle, T_Sy2FileInfo *fileInfo);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2SetParsingErrorCallback)(Sy2ParserHandle handle, ParsingErrorCallback *callback, void *callbackContext);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2SetParsingProgressCallback)(Sy2ParserHandle handle, ParsingProgressCallback *callback, void *callbackContext);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2AddParsedNodeCallback)(Sy2ParserHandle handle, T_Sy2NodeType nodeType, ParsedNodeCallback *callback, void *callbackContext);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2RemoveParsedNodeCallback)(Sy2ParserHandle handle, T_Sy2NodeType nodeType, ParsedNodeCallback *callback);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2Parse)(Sy2ParserHandle handle);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2ReadNext)(Sy2ParserHandle handle, T_Sy2Node *node);
typedef Sy2ParserStatus(SY2PARSER_API_CALL *T_sy2AbortParsing)(Sy2ParserHandle handle);

/*!
@}
*/

#ifdef __cplusplus

}
#endif

#endif
